/*
CPCS 324 : Algorithms & Data Structures 2 : Group Project Phase1
Phone Network Design App (Usage of Prim & Kruskal Algorithms)
---------------
Ayatun Ara - 2110295 - B0B
Rayana Bander Aljuaid - 2105972 - B0A
Samaher Ismael Fattani - 1905374 - B0A
Ghadeer Mohammed Nooh - 2006705 - B0A
---------------
 *///
package PhoneNetworkApp;

import GraphFramework.Edge;
import GraphFramework.MHPrimAlg;
import GraphFramework.KruskalAlg;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

//main class
public class PhoneNWDesignApp {

    //static Scanner to read user input
    static Scanner sc = new Scanner(System.in);

    public static void main(String[] args) throws FileNotFoundException {

        int input = 0;
        boolean flag = true;

        while (flag) {
            printReqMenu(); //Requirement Menu
            input = sc.nextInt();

            switch (input) {
                //requirement1
                case 1:
                    req1();
                    flag = false;
                    break;

                //requirement2
                case 2:
                    req2();
                    flag = false;
                    break;

                default:
                    System.out.println("This was a wrong input, please enter again.");
                    break;
            }
        }
    }

    //-------------------------------------------------------------------------------
    //print first requirment menu
    //-------------------------------------------------------------------------------
    public static void printReqMenu() {
        System.out.println("Choose Requirements to compute Minimum Spanning Tree:\n"
                + "With Kruskal's Algorithm & Prim's Algorithm (MinHeap)\n\n"
                + "Requirement 1: Read Graph from file\n"
                + "Requirement 2: Randomly generate undirected Graph\n"
                + "Enter Requirement: ");

    }

    //-------------------------------------------------------------------------------
    //print second requirment case menu
    //-------------------------------------------------------------------------------
    public static void printCases() {
        System.out.println("\nCases (n = no. of Offices, m = no. of Lines):\n");
        System.out.println("1:  n =  1000, m = 10000");
        System.out.println("2:  n =  1000, m = 15000");
        System.out.println("3:  n =  1000, m = 25000");
        System.out.println("4:  n =  5000, m = 15000");
        System.out.println("5:  n =  5000, m = 25000");
        System.out.println("6:  n = 10000, m = 15000");
        System.out.println("7:  n = 10000, m = 25000\n");
        System.out.print("Enter case: ");

    }

    //-------------------------------------------------------------------------------
    //method for requirement 1 : reading graph from the file
    //-------------------------------------------------------------------------------
    public static void req1() throws FileNotFoundException {
        File InputFile = new File("CPCS324.txt");
        if (!InputFile.exists()) {
            System.out.println("The input file does not exist");
        } else {

            Scanner input1 = new Scanner(InputFile);
            input1.next();
            //create new graph using the blueprint graph and call the readGraphFromFile method
            BluePrintsGraph graph = new BluePrintsGraph();
            graph.readGraphFromFile(InputFile);

            //create new kruskal object send the graph to it and print the spanning tree
            KruskalAlg kruskal = new KruskalAlg();
            kruskal.Kurskal(graph);
            System.out.println("_____________________________________________________________\n"
                    + "The phone network (minimum spanning tree) generated by Kruskal algorithm is as follows:\n");
            Edge[] MSTResultListK = kruskal.displayResultingMST();
            graph.displayResultingKruskal(MSTResultListK);
            System.out.println("\nThe cost of designed phone network: " + kruskal.getCost() + "\n");

            //create new prim object and compute the spanning tree
            MHPrimAlg MHObject = new MHPrimAlg(graph.getVerticesNo(), graph);//create new object 
            MHObject.PrimMH(graph);//call minheap method 
            System.out.println("_____________________________________________________________\n"
                    + "The phone network (minimum spanning tree) generated by Min Heap Prims algorithm is as follows:\n");
            Edge[] MSTResultListMH = MHObject.displayResultingMST();
            graph.displayResultingMHPrim(MSTResultListMH);
            System.out.println("\nThe cost of designed phone network: " + MHObject.getCost());

        }
    }

    //-------------------------------------------------------------------------------
    //method for requirement 2 : generate a new graph out of 7 cases
    //-------------------------------------------------------------------------------
    public static void req2() {

        //intialize variables
        int vertex = 0;
        int edge = 0;
        int caseNum = 0;

        //loop until correct case number
        boolean flag = true;
        while (flag) {
            //print the cases ask for all the neccesary variable
            printCases();
            caseNum = sc.nextInt();
            switch (caseNum) {
                case 1:
                    vertex = 1000;
                    edge = 10000;
                    flag = false;
                    break;
                case 2:
                    vertex = 1000;
                    edge = 15000;
                    flag = false;
                    break;
                case 3:
                    vertex = 1000;
                    edge = 25000;
                    flag = false;
                    break;
                case 4:
                    vertex = 5000;
                    edge = 15000;
                    flag = false;
                    break;
                case 5:
                    vertex = 5000;
                    edge = 25000;
                    flag = false;
                    break;
                case 6:
                    vertex = 10000;
                    edge = 15000;
                    flag = false;
                    break;
                case 7:
                    vertex = 10000;
                    edge = 25000;
                    flag = false;
                    break;
                default:
                    System.out.println("This was a wrong input, please enter again.");
            }

            //must be undirected graph since kruskal and prim's can't work with directed graphs
            boolean digraphBool = false;
            //create new graph and makegraph
            BluePrintsGraph graph = new BluePrintsGraph(vertex, edge, digraphBool);
            graph.makeGraph();//create  graph

            //create new object start timer and calculate how much it takes to run and print it      
            KruskalAlg kruskal = new KruskalAlg();
            double KruskalStartTime = System.currentTimeMillis();
            kruskal.Kurskal(graph);
            double KruskalFinishTime = System.currentTimeMillis();
            double totalTimeKruskal = KruskalFinishTime - KruskalStartTime;
            System.out.println("_____________________________________________________________\n"
                    + "Kruskal's Algorithm:\n"
                    + "Minimum Spanning Tree cost: " + kruskal.getCost()
                    + "\nTotal runtime of Kruskal Algorithm: " + totalTimeKruskal + " ms\n");

            //create new object start timer and calculate how much it takes to run and print it  
            MHPrimAlg MHObject = new MHPrimAlg(vertex, graph);//create new object 
            double minHeapStartTime = System.currentTimeMillis();//start time of minHeap 
            MHObject.PrimMH(graph);//call minheap method 
            double minHeapFinishTime = System.currentTimeMillis();//end time of minHeap
            double totalTimeMH = minHeapFinishTime - minHeapStartTime;//find the time taken by minHeap algorithm 
            //print results 
            System.out.println("_____________________________________________________________\n"
                    + "Prim's Algorithm (using Min Heap):\n"
                    + "Minimum Spanning Tree cost: " + MHObject.getCost()
                    + "\nTotal runtime of Prim Algorithm (using Min Heap): " + totalTimeMH + " ms\n");

            //check time differences for calculating the algorithms
            if (totalTimeKruskal > totalTimeMH) {
                double Tdifference = totalTimeKruskal - totalTimeMH;
                System.out.println("\nThe total runtime of the Kruskal Algorithm"
                        + " is more than the Prim's \nAlgorithm (using Min Heap) by " + Tdifference + " ms");
            } else if (totalTimeKruskal == totalTimeMH) {
                System.out.println("\nThe total runtime of the Kruskal Algorithm"
                        + " is equal to the Prim's \nAlgorithm (using Min Heap)");
            } else {
                double Tdifference = totalTimeMH - totalTimeKruskal;
                System.out.println("\n The total runtime of the Prim's Algorithm (using Min Heap)"
                        + " is more than \nthe Kruskal Algorithm by " + Tdifference + " ms.");
            }
        }
    }
}
